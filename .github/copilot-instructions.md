# Copilot Instructions for DiyBatteryBMS

- **Purpose**: Translate Victron VE.Direct telemetry into Pylontech CAN frames, expose control/telemetry over MQTT, and configure via web UI. Entry and runtime wiring live in [src/main.cpp](src/main.cpp).
- **Main runtime**: `setup()` initializes NVS prefs (`pref`), WiFi/MQTT (`WifiMQTTManagerClass`), CAN bus (`CANBUS Inverter`), display (`VEDisplay`), LittleFS, and starts web + MQTT tasks. `loop()` streams VE.Direct, forwards JSON to MQTT/WebSocket, refreshes LCD, and yields often to avoid WDT resets.
- **Concurrency**: Battery state in `Inverter` is guarded by `Inverter.CANMutex`; wrap reads/writes with `taskENTER_CRITICAL`/`taskEXIT_CRITICAL` as done in [src/main.cpp](src/main.cpp) and [src/HTTPWSFunctions.h](src/HTTPWSFunctions.h). Web tasks are FreeRTOS (`xTaskCreate`)—avoid long blocking sections.
- **Configuration storage**: Preferences persist in NVS via `mEEPROM` (`pref`). Initial defaults written in `setup()` when `EEPROMSetup` is absent. When adding new settings, set sane defaults, persist with `pref.put*`, and surface in WebSocket/REST handlers.
- **Pin safety**: GPIO validation uses `IsForbiddenPin` from [src/GPIOForbidden.h](src/GPIOForbidden.h); reject or warn on forbidden pins before persisting (see handlers in [src/HTTPWSFunctions.h](src/HTTPWSFunctions.h)).
- **Web UI**: Async web server + WebSocket declared in [src/main.cpp](src/main.cpp) and handled in [src/HTTPWSFunctions.h](src/HTTPWSFunctions.h). WebSocket messages use simple `Get...` strings or JSON `Set` payloads; config updates persist to NVS and call `notifyWSClients()` for live refresh.
- **UI templating**: Do not edit generated `data/index.htm` or `data/index-ap.htm` directly—edit the `.template` files in `data/`. [scripts/build_html.py](scripts/build_html.py) injects CAN/FAN fields per PlatformIO env (esp32dev/esp32plus use CS pin; *ESPCAN variants use TX/RX/EN; esp32c3 hides FAN) before LittleFS build.
- **MQTT**: Uses `PsychicMqttClient` in [src/mqttFunctions.h](src/mqttFunctions.h). Topics derive from `wifiManager.GetMQTTTopic()` (default `DIY-BATTERY`). Publishes `/Param/*` state and `/Data` JSON snapshots; subscribes to `/set/#` for commands. Pending messages are tracked/cleaned to avoid leaks.
- **VE.Direct ingestion**: `VeDirectFrameHandler` parses serial frames; data processed in `VEDataProcess()` then forwarded to MQTT and WebSocket. Loop throttles serial reads to keep WDT happy (50 ms slices).
- **CAN bus**: `CANBUS Inverter` abstracts MCP2515 vs ESP32 TWAI. For ESPCAN envs, TX/RX/EN pins come from NVS; for MCP2515 envs, `ccCanCSPin` and crystal speed (`ccCAN16Mhz`) matter. Enable/disable bus via `ccCANBusEnabled` and `Inverter.StartRunTask()`.
- **LCD/FAN**: LCD uses `VEDisplay` (I2C 20x4). FAN control initializes only when a valid non-forbidden pin is stored. Updates happen during LCD refresh in `loop()`.
- **NTP**: `TaskSetClock` in [src/HTTPWSFunctions.h](src/HTTPWSFunctions.h) reads comma-separated NTP servers from NVS (`ccNTPServer`) and blocks until WiFi is connected; keep that key populated to avoid early exit.
- **Build workflow**: PlatformIO default env is `esp32dev`; others: `esp32plus`, `esp32-ESPCAN`, `esp32s3-ESPCAN`, `esp32c3-ESPCAN`. `extra_scripts` run on every build: [scripts/build_html.py](scripts/build_html.py) (HTML generation) and [scripts/package_release.py](scripts/package_release.py) (packaging). LittleFS content is built via `platformio run --target buildfs --environment <env>` or the provided VS Code tasks.
- **Release packaging**: [scripts/package_release.py](scripts/package_release.py) writes ZIPs to `dist/` containing firmware, LittleFS image, bootloader, partitions, README, and flash scripts. Filesystem offset is inferred from the active `board_build.partitions` CSV when possible; esptool commands are embedded per chip family.
- **Tasks**: VS Code tasks include `PlatformIO: Build`, `Release: Build+Zip (<env>)`, `Release: Build+Zip (All Envs)`, filesystem build, and erase+upload variants. Use `Release: Clean Dist` before regenerating artifacts to avoid stale ZIPs.
- **File system**: LittleFS is mounted at startup; update server is available at `/update` via `ESPAsyncHTTPUpdateServer` (LittleFS enabled). Keep `board_build.filesystem` set to `littlefs` per env.
- **Home Assistant integration**: Example commands/topics are documented in [README.md](README.md) and `HomeAssistant.yaml` at repo root; align new MQTT commands with those patterns.
- **Template-driven boards**: Pin recommendations per env are listed in [README.md](README.md). Forbidden pin lists differ per env and are injected via `build_flags` in [platformio.ini](platformio.ini); respect them when proposing defaults.
- **Debugging**: Logs use Arduino `log_d/log_i/log_w/log_e`; ensure `CORE_DEBUG_LEVEL` build flag is high enough for diagnostics (currently 4). Watchdog timeouts are mitigated by short `loop()` sections, `yield()`, and `delay(1)`—preserve this pacing when adding work.
- **Adding new settings**: Touch points: defaults in [src/main.cpp](src/main.cpp) `pref.put*`, serialization in `generateDatatoJSON()`, WebSocket setters in [src/HTTPWSFunctions.h](src/HTTPWSFunctions.h), and any UI fields in `data/*.template` plus handlers in [scripts/build_html.py](scripts/build_html.py).
